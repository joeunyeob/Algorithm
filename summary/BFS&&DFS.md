## 너비 우선 탐색(Breath First Search) - BFS 

**너비 우선 탐색** 은 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘 입니다. 

- 너비 우선 탐색은 '최단 경로'를 찾아준다는 점에서 최단 길이를 보장해야 할 때 많이 사용한다.

  

  **너비 우선 탐색** 은 트리나 그래프를 방문 또는 탐색하는 방법이다. 탐색 방법은 다음과 같다

  1. 루트에서 시작한다.
  2. 자식 노드들을 [1]에 저장한다.
  3. [1]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [2]에 저장한다.
  4. [2]에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 [3]에 저장한다.
  5. 위의 과정을 반복한다.
  6. 모든 노드를 방문하면 탐색을 마친다.

#### 특징

- DFS	와의 가장 큰 차이로, 여러 갈래 중 무한한 길이를 가지는 경로가 존재하고 탐색 목표가 다른 경로에 존재하는 경우 DFS로 탐색할 시에는 무한한 길이의 경로에서 영원히 종료를 하지 못하지만, BFS의 경우는 모든 경로를 동시에 진행하기 때문에 탐색이 가능하다는 특징이 있다.

#### 소스 코드로의 구현

- BFS는 재귀 호출(Recurison Call)을 이용하여 소스 코드로 구현하는 DFS와는 달리, Queue를 사용하는 경우가 일반적이다. 배열에서 사용하는 경우, 방향 데이터를 이용해 시작점에서 범위를 넓혀 가면서 탐색하는 것이다.



![bfsì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://upload.wikimedia.org/wikipedia/commons/thumb/3/33/Breadth-first-tree.svg/1200px-Breadth-first-tree.svg.png)



이러한 **BFS는 너비를 우선으로 하여 탐색한다는 특성** 이 중요한 것이고, 이를 잉용해 다른 알고리즘에 적용한다는 것이 핵심입니다. BFSS는 그 자체로는 큰 의미가 없다고 보면 된다.

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.childs = []


def bfs(A):
    q = []
    visited = set()

    while q:
        node = q.pop(0)
        if node in visited:
            continue
        print(node.data)
        q.extend(node.childs)
```

---

## 깊이 우선 탐색(Depth First Search) - DFS

- 트리나 그래프에서 한 루트로 탐색하다가 특정 상황에서 최대한 깊숙히 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방식이다. 일반적으로 **재귀호출** 을 사용하여 구현하지만 스택으로 구현하기도 한다. 구조상 **스택 오버플로우** 를 유의해야 한다.
- 단순 검색 속도 자체는 BFS에 비해서 느리다.

![DFSì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://t1.daumcdn.net/cfile/tistory/2123283A51FF79DB46)

### 장점

- 단지 현 경로상의 노드들만을 기억하면 되므로 저장 공간의 수요가 비교적 작다.
- 목표 노드가 깊은 단계이 있을 경우 해를 빨리 구할 수 있다.

### 단점

- 해가 없는 경로에 깊이 빠질 가능성이 있다. 따라서 실제로는 미리 지정한 임의 깊이까지만 탐색하고 목표 노드를 발견하지 못하면 다음 경로를 따라 탐색하는 방법이 유용할 수 있다.
- 얻어진 해가 최단 경로가 된다는 보장이 없다. 이는 목표에 이르는 경로가 다수인 문제에 대해 깊이우선탐색은 해에 다다르면 탐색을 끝내버리므로, 이때 얻어진 해는 최적이 아닐 수 있다는 의미이다.



```python
def DFS_visit(adj, u, visited):
    visited.append(u)
    for v in adj[u]:
        if v not in visited:
            DFS_visit(adj, v, visited)


def DFS(adj, s):
    visited = []
    DFS_visit(adj, s, visited)
    return visited


G1 = {1: [2, 3], 2: [3, 4, 5],
      3: [5, 7, 8], 4: [5],
      5: [6], 6: [], 7: [8],
      8: []}

print(DFS(G1, 1))
```

